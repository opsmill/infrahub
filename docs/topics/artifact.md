---
label: Artifact
layout: default
---

# Artifact

An artifact is the result of a [Transformation](./transformation.md) for a specific context and/or object, it can have different format either in plain text or JSON.

!!!success Examples
- For a network device, an artifact can be used to track the configuration generated from a Jinja template (RFile)
- For a Security Device, an artifact can be the list of rules in JSON in the format of your choice generated by a Python Transformation
An artifact can also represent the configuration of a DNS server or the configuration of a specific Virtual IP on a load balancer.
!!!

While it's always possible to generate [Transformations](./transformation.md) on demand via the API, having an Artifact provide some additional benefits:
- **Caching** : Generated Artifact are stored in the internal [object storage](./object-storage.md). For resource intensive Transformation, it will significantly reduce the load of the system if an artifact can be serve from the cache instead of regenerating each time.
- **Traceability** : Past values of an artifact remains available. In a future release, it will be possible to compare the value of an artifact over time.
- **Peer Review** : Artifact are automatically part of the Proposed Change review process

While the content of an artifact can change, it's identifier will remain the same over time.

## High level design

Artifacts are defined by grouping a [Transformation](./transformation.md) with a Group of targets in an Artifact Definition.

An Artifact Definition centralize all the information required to generate an artifact
- Group of targets
- Transformation
- Format of the output
- Information to extract from each target that must be passed to the Transformation.

![](../media/artifact.excalidraw.svg)

## Artifact Definition

Artifact Definition can be created via the Frontend, via GraphQL or via a Git Repository

For Infrahub to automatically import an ArtifactDefinition from a Repository, it must be declare in the `.infrahub.yml` file at the root of the repository under the key `artifact_definitions`.

```yaml
---
artifact_definitions:
  - name: "<name of the artifact definition"
    artifact_name: "<name of the artifact generate for each member of the group"
    parameters:
      key1: "value1"
    content_type: "text/plain"
    targets: "<name or ID of a groups>"
    transformation: "<name or ID of a transformation>"
```

## Artifact

Artifact can be accessed via the frontend and via GraphQL but they shouldn't be manually created, all artifacts should be generated and managed by Infrahub.

## Examples

### Startup Configuration for Edge devices

The project [infrahub-demo-edge](https://github.com/opsmill/infrahub-demo-edge) includes most elements to generate the startup configuration of all Edge Devices.

in the `.infrahub.yml` the actifact definition is configured as follow:

```yaml
artifact_definitions:
  - name: "Startup Config for Edge devices"
    artifact_name: "startup-config"
    parameters:
      device: "name__value"
    content_type: "text/plain"
    targets: "edge_router"
    transformation: "device_startup"
```

- `transformation: "device_startup"` reference the Transformation RFile also define in the same repository.
 - The GraphQLQuery `device_startup_info` is indirectly connected to the Artifact Definition via the Transformation.
- `targets: "edge_router"` reference a group of Edge routers named `edge_router`, it must be already present in Infrahub
- `parameters` define the information that must be extracted from each member of the group and that must be passed to the Transformation. Here the Transformation `device_startup` must have a parameter `device` (coming from the GraphQL Query) to render the configuration properly. The value of `device` for each member of the group will be constructed by accessing the value of the name `name__value`





